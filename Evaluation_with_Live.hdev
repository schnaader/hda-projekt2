<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.1" halcon_version="13.0.1.1">
<procedure name="main">
<interface/>
<body>
<c>* MIT License</c>
<c></c>
<c>* Copyright (c) 2018 Tobias Nixdorf</c>
<c></c>
<c>* Permission is hereby granted, free of charge, to any person obtaining a copy</c>
<c>* of this software and associated documentation files (the "Software"), to deal</c>
<c>* in the Software without restriction, including without limitation the rights</c>
<c>* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</c>
<c>* copies of the Software, and to permit persons to whom the Software is</c>
<c>* furnished to do so, subject to the following conditions:</c>
<c></c>
<c>* The above copyright notice and this permission notice shall be included in all</c>
<c>* copies or substantial portions of the Software.</c>
<c></c>
<c>* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</c>
<c>* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</c>
<c>* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</c>
<c>* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</c>
<c>* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</c>
<c>* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</c>
<c>* SOFTWARE.</c>
<c></c>
<c></c>
<c></c>
<l>Height_Ref_Image:=1024</l>
<l>Width_Ref_Image:=1024</l>
<c></c>
<l>back_brightness:=255</l>
<l>dot_brightness:=0</l>
<c></c>
<l>dot_Radius:=10.5</l>
<l>spacing_x:=150</l>
<l>spacing_y:=150</l>
<c></c>
<l>Live:=0</l>
<c></c>
<c>*get Timestamp</c>
<l>get_system_time (MSecond, Second, Minute, Hour, Day, YDay, Month, Year)</l>
<l>Timestamp:=Year*10000000000000+Month*100000000000+Day*1000000000+Hour*10000000+Minute*100000+Second*1000+MSecond</l>
<c></c>
<c></c>
<c>*generating a dot matrix</c>
<l>dot_gen (ResultImages, ImageResult2, Width_Ref_Image, Height_Ref_Image, back_brightness, spacing_x, spacing_y, dot_Radius, dot_brightness)</l>
<l>for Index := 1 to 5 by 1</l>
<l> dev_close_window ()   </l>
<l>endfor</l>
<c></c>
<c></c>
<l>dev_open_window_fit_size (0, 0, Width_Ref_Image, Height_Ref_Image, -1, -1, WindowHandle)</l>
<l>dev_open_window_fit_size (0, 600, Width_Ref_Image, Height_Ref_Image, -1, -1, WindowHandle2)</l>
<l>dev_set_window (WindowHandle)</l>
<l>dev_display (ImageResult2)</l>
<c></c>
<c></c>
<l>if(Live)</l>
<l>    init_Camera (AcqHandle, Exception)</l>
<l>endif</l>
<c></c>
<l>dev_set_window (WindowHandle2)</l>
<c></c>
<l>if(Live)</l>
<l>    grab_image(ImageRef, AcqHandle) </l>
<l>else</l>
<l>    read_image (ImageRef, '../hda-projekt2/Brojekt 2/Ref/test.tiff')</l>
<l>endif</l>
<l>dev_display (ImageRef)</l>
<c></c>
<c></c>
<l>if(Live)</l>
<c></c>
<l>else</l>
<l>    read_image (ImageChanged, '../hda-projekt2/Brojekt 2/Test2 ID002/test32.tiff')</l>
<l>endif</l>
<c></c>
<l>dev_display (ImageRef)</l>
<c></c>
<c></c>
<l>median_image (ImageRef, ImageMedian, 'circle', 10, 'mirrored')</l>
<l>dyn_threshold (ImageRef, ImageMedian, RegionDynThresh, 40, 'dark')</l>
<l>opening_circle (RegionDynThresh, RegionOpening, 3.5)</l>
<l>closing_circle (RegionOpening, RegionClosing, 15.5)</l>
<l>connection (RegionClosing, ConnectedRegions1)</l>
<l>select_shape (ConnectedRegions1, SelectedRegions, 'area', 'and', 42.585, 100)</l>
<l>union1 (SelectedRegions, RegionUnion)</l>
<l>smallest_rectangle2 (RegionUnion, Row, Column, Phi, Length1, Length2)</l>
<l>gen_rectangle2 (Rectangle2, Row, Column, Phi, Length1, Length2)</l>
<c></c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity, 3.1415*1/2-Phi,  Row,Column, HomMat2DRotate)</l>
<l>affine_trans_image (ImageRef, ImageRotate, HomMat2DRotate, 'constant', 'false')</l>
<c></c>
<c></c>
<l>median_image (ImageRotate, ImageMedian, 'circle', 10, 'mirrored')</l>
<l>dyn_threshold (ImageRotate, ImageMedian, RegionDynThresh, 35, 'dark')</l>
<l>opening_circle (RegionDynThresh, RegionOpening, 3.5)</l>
<l>closing_circle (RegionOpening, RegionClosing, 15.5)</l>
<l>connection (RegionClosing, ConnectedRegions1)</l>
<l>select_shape (ConnectedRegions1, SelectedRegions, 'area', 'and', 42.585, 100)</l>
<l>count_obj (SelectedRegions, Number)</l>
<l>Side_number:=int(sqrt(Number))</l>
<l>union1 (SelectedRegions, RegionUnion)</l>
<l>smallest_rectangle2 (RegionUnion, Row, Column, Phi, Length1, Length2)</l>
<c></c>
<l>gen_rectangle2 (Rectangle1, Row, Column, Phi, Length1+Length1/(Side_number-1), Length2+Length2/(Side_number-1))</l>
<c></c>
<l>gen_empty_obj (Regions)</l>
<l>rowsref:=[]</l>
<l>columsref:=[]</l>
<l>rowschanged:=[]</l>
<l>columschanged:=[]</l>
<c></c>
<l>for j := 0 to Side_number-1 by 1</l>
<l>    for i := 0 to Side_number-1 by 1</l>
<l>        clip_region (Rectangle1, RegionClipped, (Row-(Length1+Length1/(Side_number))+ (Length1*2/(Side_number-1))*(j)), Column-(Length2+Length2/(Side_number))+ ((Length2*2)/(Side_number-1))*(i), Row-(Length1+Length1/(Side_number)) + (Length1*2/(Side_number-1))*(j+1), Column-(Length2+Length2/(Side_number)) + ((Length2*2)/(Side_number-1))*(i+1))</l>
<l>        intersection (RegionDynThresh, RegionClipped, RegionIntersection)</l>
<l>        region_features (RegionIntersection, 'row', row_out)</l>
<l>        region_features (RegionIntersection, 'column', column_out)</l>
<l>        rowsref:=[rowsref,row_out]</l>
<l>        columsref:=[columsref,column_out]</l>
<l>        concat_obj (Regions, RegionClipped, Regions)</l>
<l>    endfor</l>
<l>endfor</l>
<c></c>
<l>hom_mat2d_rotate (HomMat2DRotate, -(3.1415*1/2-Phi), Column, Row, HomMat2DRotate1)</l>
<l>affine_trans_region (Regions, RegionAffineTrans, HomMat2DRotate1, 'nearest_neighbor')</l>
<l>count_obj (RegionAffineTrans, Number1)</l>
<c></c>
<l>segment_dots (ImageRef, RegionAffineTrans, rowref, columnref)</l>
<c></c>
<l>while(1)</l>
<l>    if(Live)</l>
<l>        grab_image(ImageChanged, AcqHandle)        </l>
<l>    endif</l>
<c>    </c>
<c>    </c>
<l>    segment_dots (ImageChanged, RegionAffineTrans, rowschanged, columchanged)</l>
<l>    distance_pp (rowref, columnref, rowschanged, columchanged, Distance)</l>
<c>    </c>
<l>    *disp_arrow (WindowHandle2, rowsref, columsref, rowchanged, columchanged,3)</l>
<l>    tuple_find (rowsref, 0.0, Indices1)</l>
<l>    tuple_find (columnref, 0.0, Indices2)</l>
<l>    tuple_find (rowschanged, 0.0, Indices3)</l>
<l>    tuple_find (columchanged, 0.0, Indices4)</l>
<l>    Indicesremove:=[Indices1,Indices2,Indices3,Indices4]</l>
<l>   tuple_find (Indicesremove, -1, Indices5)</l>
<l>   tuple_remove (Indicesremove, Indices5, Indicesremove)</l>
<c>  </c>
<l>     tuple_remove (Distance, Indicesremove, Distance)   </l>
<c>    </c>
<l>    distance_px:=10000</l>
<l>    n:=1.4</l>
<l>    Alphax:=atan((rowsref-rowschanged)/distance_px)</l>
<l>    Alphay:=atan((columnref-columchanged)/distance_px)</l>
<l>    Anglex:=atan((sin(Alphax))/(n-cos(Alphax)))</l>
<l>    Angley:=atan((sin(Alphay))/(n-cos(Alphay)))</l>
<l>        if(Live)</l>
<l>            dev_display (ImageChanged)</l>
<c>           **// disp_arrow (WindowHandle2, rowsref, columsref, rowsref+Anglex,columsref+ Angley,3)</c>
<c></c>
<l>    else</l>
<c>        **disp_arrow (WindowHandle2, rowsref, columsref, rowsref+Anglex,columsref+ Angley,3)</c>
<l>*disp_arrow (WindowHandle2, rowsref, columnref, rowschanged, columchanged, 2)</l>
<c>    </c>
<l>*convert_tuple_to_vector_1d (Anglex, |Distance|, ResultVectorx)</l>
<l>*convert_tuple_to_vector_1d (Angley, |Distance|, ResultVectory)</l>
<c>**TRing to interpolate some kind of surface structure </c>
<l>  NumberRects:=Number1 </l>
<l>  NumberGridPointsxory:=int(sqrt(NumberRects))</l>
<c>  </c>
<c>*tupleTest:=at(0).Anglex[0:(NumberGridPoints-1)]</c>
<c>    </c>
<l>           tuple_replace (Anglex, Indicesremove, 0.0, Anglexnew)</l>
<l> convert_tuple_to_vector_1d (Anglexnew, NumberGridPointsxory, ResultVector)</l>
<c> </c>
<c></c>
<c> </c>
<l> heightx:=[]</l>
<l> for Indexy := 0 to NumberGridPointsxory-1 by 1</l>
<l>  heightxSeed:=[0.0]  </l>
<l>     for Indexx := 0 to NumberGridPointsxory-1 by 1</l>
<c>        *surface curve in one dimension should be easy to estimate </c>
<c>        *combining it with a secon dimension needs interpolation between conflicting angles</c>
<l>        heightxSeed:=[heightxSeed,heightxSeed[Indexx]+ResultVector.at(Indexy)[Indexx]]</l>
<c>        </c>
<l>    endfor</l>
<l>    heightx:=[heightx,heightxSeed]</l>
<l> endfor</l>
<c>*tuple of tuples containing a curve in x direction each starting at 0 </c>
<l> convert_tuple_to_vector_1d (heightx, NumberGridPointsxory+1, ResultVectornew)     </l>
<c> </c>
<l> CurveDegre:=3</l>
<l> someTangents:=(Anglexnew[0:5]/3.1415)*180</l>
<l> Rows:=[0:1:(NumberGridPointsxory-1)]</l>
<l> Cols:=heightx[0:(NumberGridPointsxory-1)]</l>
<l>*gen_nurbs_interp (Rows,Cols,someTangents,CurveDegre, CtrlRows1, CtrlCols1, Knots1)</l>
<l>*gen_contour_nurbs_xld (Contour, CtrlRows, CtrlCols, Knots, 'auto', 3, 1, 5)</l>
<c> </c>
<c> *Visualisation of 3D models</c>
<l>X:=[0,1,1,0]</l>
<l>Y:=[0,0,1,1]</l>
<l>Z:=[0,0,0,0]</l>
<l>gen_object_model_3d_from_points (X, Y, Z, ObjectModel3D)</l>
<l>*xyz_to_object_model_3d(X, Y, Z, ObjectModel3D)</l>
<l>gen_cam_par_area_scan_division (0.016, 0, 5e-6, 5e-6, 320, 240, 640, 480, CamParam)</l>
<l>create_pose (-0.02, 0.01, .6, 110, 5, 320, 'Rp+T', 'gba', 'point', Pose1)</l>
<l>visualize_object_model_3d (WindowHandle, ObjectModel3D, CamParam, Pose1, [], [], ['test'], [], [], PoseOut)</l>
<c></c>
<l>break</l>
<c>        </c>
<l>    endif</l>
<l>endwhile</l>
<c></c>
<c>*CSV Data Output</c>
<l>open_file ('/Users/tobiasnixdorf/Documents/h-da/6 Semester/Project2/hda-projekt2/Out_Data/'+Timestamp+'_Data.csv', 'output', FileHandle)</l>
<l>FirstLine:=['Number',';','Row_Reference',';','Column_Reference',';','xAngle',';','yAngle']</l>
<l>fwrite_string (FileHandle, FirstLine)</l>
<c></c>
<l>for Index1 := 0 to |rowsref|-1 by 1</l>
<l>   TempString:=[Index1,';',rowsref[Index1],';',columsref[Index1],';',Anglex[Index1],';',Angley[Index1]]</l>
<l>   fnew_line (FileHandle)</l>
<l>  fwrite_string (FileHandle, TempString)  </l>
<l>endfor</l>
<c></c>
<l>close_file (FileHandle)</l>
<c></c>
<c></c>
<c></c>
<c></c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
</hdevelop>
