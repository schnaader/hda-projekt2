<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.1" halcon_version="13.0.1.1">
<procedure name="visualize_object_model_3d">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3D" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="PoseIn" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="Title" base_type="ctrl" dimension="0"/>
<par name="Label" base_type="ctrl" dimension="0"/>
<par name="Information" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PoseOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* The procedure visualize_object_model_3d can be used to display</c>
<c>* one or more 3d object models and to interactively modify</c>
<c>* the object poses by using the mouse.</c>
<c>* </c>
<c>* The pose can be modified by moving the mouse while</c>
<c>* pressing a mouse button. The default settings are:</c>
<c>* </c>
<c>*  Rotate: Left mouse button</c>
<c>*  Zoom: Shift + Left mouse button (or Center mouse button)</c>
<c>*  Pan: Ctrl + Left mouse button</c>
<c>* </c>
<c>* Furthermore, it is possible to select and deselect objects,</c>
<c>* to decrease the mouse sensitivity, and to toggle the</c>
<c>* inspection mode (see the description of the generic parameter</c>
<c>* 'inspection_mode' below):</c>
<c>* </c>
<c>*  (De-)select object(s): Right mouse button</c>
<c>*  Low mouse sensitivity: Alt + Mouse button</c>
<c>*  Toggle inspection mode: Ctrl + Alt + Left mouse button</c>
<c>* </c>
<c>* In GenParamName and GenParamValue all generic Parameters</c>
<c>* of disp_object_model_3d are supported.</c>
<c>* </c>
<c>* **********************************************************</c>
<c>* Define global variables</c>
<c>* **********************************************************</c>
<c>* </c>
<l>global def tuple gDispObjOffset</l>
<l>global def tuple gLabelsDecor</l>
<l>global def tuple gInfoDecor</l>
<l>global def tuple gInfoPos</l>
<l>global def tuple gTitlePos</l>
<l>global def tuple gTitleDecor</l>
<l>global def tuple gTerminationButtonLabel</l>
<l>global def tuple gAlphaDeselected</l>
<l>global def tuple gIsSinglePose</l>
<l>global def tuple gUsesOpenGL</l>
<c>* </c>
<c>* **********************************************************</c>
<c>* Initialize Handles to enable correct handling in error case</c>
<c>* **********************************************************</c>
<l>Scene3DTest := []</l>
<l>Scene3D := []</l>
<l>WindowHandleBuffer := []</l>
<c></c>
<c>* **********************************************************</c>
<c>* Some user defines that may be adapted if desired</c>
<c>* **********************************************************</c>
<c>* </c>
<c>* TrackballSize defines the diameter of the trackball in</c>
<c>* the image with respect to the smaller image dimension.</c>
<l>TrackballSize := 0.8</l>
<c>* </c>
<c>* VirtualTrackball defines the type of virtual trackball that</c>
<c>* shall be used ('shoemake' or 'bell').</c>
<l>VirtualTrackball := 'shoemake'</l>
<l>* VirtualTrackball := 'bell'</l>
<c>* </c>
<c>* Functionality of mouse buttons</c>
<c>*     1: Left Button</c>
<c>*     2: Middle Button</c>
<c>*     4: Right Button</c>
<c>*     5: Left+Right Mousebutton</c>
<c>*   8+x: Shift + Mousebutton</c>
<c>*  16+x: Ctrl + Mousebutton</c>
<c>*  48+x: Ctrl + Alt + Mousebutton</c>
<c>* in the order [Translate, Rotate, Scale, ScaleAlternative1, ScaleAlternative2, SelectObjects, ToggleSelectionMode]</c>
<l>MouseMapping := [17,1,2,5,9,4,49]</l>
<c>* </c>
<c>* The labels of the objects appear next to their projected</c>
<c>* center. With gDispObjOffset a fixed offset is added</c>
<c>*                   R,  C</c>
<l>gDispObjOffset := [-30,0]</l>
<c>* </c>
<c>* Customize the decoration of the different text elements</c>
<c>*               Color,   Box</c>
<l>gInfoDecor := ['white','false']</l>
<l>gLabelsDecor := ['white','false']</l>
<l>gTitleDecor := ['black','true']</l>
<c>* </c>
<c>* Customize the position of some text elements</c>
<c>*   gInfoPos has one of the values</c>
<c>*   {'UpperLeft', 'LowerLeft', 'UpperRight'}</c>
<l>gInfoPos := 'LowerLeft'</l>
<c>*   gTitlePos has one of the values</c>
<c>*   {'UpperLeft', 'UpperCenter', 'UpperRight'}</c>
<l>gTitlePos := 'UpperLeft'</l>
<c>* Alpha value (=1-transparency) that is used for visualizing</c>
<c>* the objects that are not selected</c>
<l>gAlphaDeselected := 0.3</l>
<c>* Customize the label of the continue button</c>
<l>gTerminationButtonLabel := ' Continue '</l>
<c>* Define if the continue button responds to a single click event or</c>
<c>* if it responds only if the mouse button is released while being placed</c>
<c>* over the continue button.</c>
<c>* 'true':  Wait until the continue button has been released.</c>
<c>*          This should be used to avoid unwanted continuations of</c>
<c>*          subsequent calls of visualize_object_model_3d, which can</c>
<c>*          otherwise occur if the mouse button remains pressed while the</c>
<c>*          next visualization is active.</c>
<c>* 'false': Continue the execution already if the continue button is</c>
<c>*          pressed. This option allows a fast forwarding through</c>
<c>*          subsequent calls of visualize_object_model_3d.</c>
<l>WaitForButtonRelease := 'true'</l>
<c>* Number of 3D Object models that can be selected and handled individually.</c>
<c>* If there are more models passed then this number, some calculations</c>
<c>* are performed differently and the individual selection and handling</c>
<c>* of models is not supported anymore. Note that the value of MaxNumModels</c>
<c>* can be overwritten with the generic parameter max_num_selectable_models.</c>
<l>MaxNumModels := 1000</l>
<c>* Defines the default for the initial state of the rotation center:</c>
<c>* (1) The rotation center is fixed in the center of the image and lies</c>
<c>*     on the surface of the object.</c>
<c>* (2) The rotation center lies in the center of the object.</c>
<l>WindowCenteredRotation := 2</l>
<c>* </c>
<c>* **********************************************************</c>
<c>* </c>
<c>* Initialize some values</c>
<l>NumModels := |ObjectModel3D|</l>
<l>SelectedObject := gen_tuple_const(NumModels,1)</l>
<c>* </c>
<c>* Apply some system settings</c>
<l>dev_set_preferences ('graphics_window_context_menu', 'false')</l>
<l>dev_get_preferences ('suppress_handled_exceptions_dlg', SuppressExceptDlg)</l>
<l>dev_set_preferences ('suppress_handled_exceptions_dlg', 'true')</l>
<l>dev_get_preferences ('graphics_window_mouse_wheel', WindowMouseWheel)</l>
<l>dev_set_preferences ('graphics_window_mouse_wheel', 'false')</l>
<l>get_system ('clip_region', ClipRegion)</l>
<l>set_system ('clip_region', 'false')</l>
<l>dev_update_off ()</l>
<c>* </c>
<c>* Check if GenParamName matches GenParamValue</c>
<l>if (|GenParamName| != |GenParamValue|)</l>
<l>    throw ('Number of generic parameters does not match number of generic parameter values')</l>
<l>endif</l>
<c>* </c>
<l>try</l>
<c>    * </c>
<c>    * Refactor camera parameters to fit to window size</c>
<c>    * </c>
<l>    CPLength := |CamParam|</l>
<l>    get_window_extents (WindowHandle, RowNotUsed, ColumnNotUsed, Width, Height)</l>
<l>    get_part (WindowHandle, WPRow1, WPColumn1, WPRow2, WPColumn2)</l>
<l>    set_part (WindowHandle, 0, 0, Height - 1, Width - 1)</l>
<l>    if (CPLength == 0)</l>
<l>        gen_cam_par_area_scan_division (0.06, 0, 8.5e-6, 8.5e-6, Width / 2, Height / 2, Width, Height, CamParam)</l>
<l>    else</l>
<l>        get_cam_par_data (CamParam, ['sx','sy','cx','cy','image_width','image_height'], CamParamValue)</l>
<l>        CamWidth := real(CamParamValue[4])</l>
<l>        CamHeight := real(CamParamValue[5])</l>
<l>        Scale := min([Width / CamWidth,Height / CamHeight])</l>
<l>        set_cam_par_data (CamParam, 'sx', CamParamValue[0] / Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'sy', CamParamValue[1] / Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'cx', CamParamValue[2] * Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'cy', CamParamValue[3] * Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'image_width', int(CamParamValue[4] * Scale), CamParam)</l>
<l>        set_cam_par_data (CamParam, 'image_height', int(CamParamValue[5] * Scale), CamParam)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Check the generic parameters for max_num_selectable_models</c>
<c>    * (Note that the default is set above to MaxNumModels := 1000)</c>
<l>    Indices := find(GenParamName,'max_num_selectable_models')</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        if (is_number(GenParamValue[Indices[0]]))</l>
<l>            if (int(number(GenParamValue[Indices[0]])) &lt; 1)</l>
<c>                * Wrong parameter value: Only integer values greater than 0 are allowed</c>
<l>                throw ('Wrong value for parameter \'max_num_selectable_models\' (must be an integer value greater than 0)')</l>
<l>            endif</l>
<l>        else</l>
<c>            * Wrong parameter value: Only integer values greater than 0 are allowed</c>
<l>            throw ('Wrong value for parameter \'max_num_selectable_models\' (must be an integer value greater than 0)')</l>
<l>        endif</l>
<l>        MaxNumModels := int(number(GenParamValue[Indices[0]]))</l>
<l>        GenParamName := remove(GenParamName,Indices)</l>
<l>        GenParamValue := remove(GenParamValue,Indices)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Check the generic parameters for window_centered_rotation</c>
<c>    * (Note that the default is set above to WindowCenteredRotation := 2)</c>
<l>    Indices := find(GenParamName,'inspection_mode')</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        if (GenParamValue[Indices[0]] == 'surface')</l>
<l>            WindowCenteredRotation := 1</l>
<l>        elseif (GenParamValue[Indices[0]] == 'standard')</l>
<l>            WindowCenteredRotation := 2</l>
<l>        else</l>
<c>            * Wrong parameter value, use default value</c>
<l>        endif</l>
<l>        GenParamName := remove(GenParamName,Indices)</l>
<l>        GenParamValue := remove(GenParamValue,Indices)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Check the generic parameters for disp_background</c>
<c>    * (The former parameter name 'use_background' is still supported</c>
<c>    *  for compatibility reasons)</c>
<l>    DispBackground := 'false'</l>
<l>    if (|GenParamName| &gt; 0)</l>
<l>        Mask := GenParamName [==] 'disp_background' or GenParamName [==] 'use_background'</l>
<l>        Indices := find(Mask,1)</l>
<l>    else</l>
<l>        Indices := -1</l>
<l>    endif</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        DispBackground := GenParamValue[Indices[0]]</l>
<l>        if (DispBackground != 'true' and DispBackground != 'false')</l>
<c>            * Wrong parameter value: Only 'true' and 'false' are allowed</c>
<l>            throw ('Wrong value for parameter \'disp_background\' (must be either \'true\' or \'false\')')</l>
<l>        endif</l>
<c>        * Note the the background is handled explicitly in this procedure</c>
<c>        * and therefore, the parameter is removed from the list of</c>
<c>        * parameters and disp_background is always set to true (see below)</c>
<l>        GenParamName := remove(GenParamName,Indices)</l>
<l>        GenParamValue := remove(GenParamValue,Indices)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Read and check the parameter Label for each object</c>
<l>    if (|Label| == 0)</l>
<l>        Label := 0</l>
<l>    elseif (|Label| == 1)</l>
<l>        Label := gen_tuple_const(NumModels,Label)</l>
<l>    else</l>
<l>        if (|Label| != NumModels)</l>
<c>            * Error: Number of elements in Label does not match the</c>
<c>            * number of object models</c>
<l>            stop ()</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Read and check the parameter PoseIn for each object</c>
<l>    get_object_models_center (ObjectModel3D, Center)</l>
<l>    if (|PoseIn| == 0)</l>
<c>        * If no pose was specified by the caller, automatically calculate</c>
<c>        * a pose that is appropriate for the visualization.</c>
<c>        * Set the initial model reference pose. The orientation is parallel</c>
<c>        * to the object coordinate system, the position is at the center</c>
<c>        * of gravity of all models.</c>
<l>        create_pose (-Center[0], -Center[1], -Center[2], 0, 0, 0, 'Rp+T', 'gba', 'point', PoseIn)</l>
<l>        determine_optimum_pose_distance (ObjectModel3D, CamParam, 0.9, PoseIn, PoseEstimated)</l>
<l>        Poses := []</l>
<l>        HomMat3Ds := []</l>
<l>        Sequence := [0:NumModels * 7 - 1]</l>
<l>        Poses := PoseEstimated[Sequence % 7]</l>
<l>        gIsSinglePose := true</l>
<l>    elseif (|PoseIn| == 7)</l>
<l>        Poses := []</l>
<l>        HomMat3Ds := []</l>
<l>        Sequence := [0:NumModels * 7 - 1]</l>
<l>        Poses := PoseIn[Sequence % 7]</l>
<l>        gIsSinglePose := true</l>
<l>    else</l>
<l>        if (|PoseIn| != |ObjectModel3D| * 7)</l>
<c>            * Error: Wrong number of values of input control parameter 'PoseIn'</c>
<l>            stop ()</l>
<l>        else</l>
<l>            Poses := PoseIn</l>
<l>        endif</l>
<l>        gIsSinglePose := false</l>
<l>    endif</l>
<c></c>
<c>    * </c>
<c>    * Open (invisible) buffer window to avoid flickering</c>
<l>    open_window (0, 0, Width, Height, 0, 'buffer', '', WindowHandleBuffer)</l>
<l>    set_part (WindowHandleBuffer, 0, 0, Height - 1, Width - 1)</l>
<l>    get_font (WindowHandle, Font)</l>
<l>    try</l>
<l>        set_font (WindowHandleBuffer, Font)</l>
<l>    catch (Exception)</l>
<l>    endtry</l>
<c>    * </c>
<c>    *  Is OpenGL available and should it be used?</c>
<l>    gUsesOpenGL := 'true'</l>
<l>    Indices := find(GenParamName,'opengl')</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        gUsesOpenGL := GenParamValue[Indices[0]]</l>
<l>        GenParamName := remove(GenParamName,Indices)</l>
<l>        GenParamValue := remove(GenParamValue,Indices)</l>
<l>        if (gUsesOpenGL != 'true' and gUsesOpenGL != 'false')</l>
<c>            * Wrong parameter value: Only 'true' and 'false' are allowed</c>
<l>            throw ('Wrong value for parameter \'opengl\' (must be either \'true\' or \'false\')')</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (gUsesOpenGL == 'true')</l>
<l>        get_system ('opengl_info', OpenGLInfo)</l>
<l>        if (OpenGLInfo == 'No OpenGL support included.')</l>
<l>            gUsesOpenGL := 'false'</l>
<l>        else</l>
<l>            gen_object_model_3d_from_points (0, 0, 0, DummyObjectModel3D)</l>
<l>            create_scene_3d (Scene3DTest)</l>
<l>            add_scene_3d_camera (Scene3DTest, CamParam, CameraIndexTest)</l>
<l>            determine_optimum_pose_distance (DummyObjectModel3D, CamParam, 0.9, [0,0,0,0,0,0,0], PoseTest)</l>
<l>            add_scene_3d_instance (Scene3DTest, DummyObjectModel3D, PoseTest, InstanceIndexTest)</l>
<l>            try</l>
<l>                display_scene_3d (WindowHandleBuffer, Scene3DTest, InstanceIndexTest)</l>
<l>            catch (Exception)</l>
<l>                gUsesOpenGL := 'false'</l>
<l>            endtry</l>
<l>            clear_scene_3d (Scene3DTest)</l>
<l>            Scene3DTest := []</l>
<l>            clear_object_model_3d (DummyObjectModel3D)</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Compute the trackball</c>
<l>    MinImageSize := min([Width,Height])</l>
<l>    TrackballRadiusPixel := TrackballSize * MinImageSize / 2.0</l>
<c>    * </c>
<c>    * Measure the text extents for the continue button in the</c>
<c>    * graphics window</c>
<l>    get_string_extents (WindowHandleBuffer, gTerminationButtonLabel + '  ', Ascent, Descent, TextWidth, TextHeight)</l>
<c>    * </c>
<c>    * Store background image</c>
<l>    if (DispBackground == 'false')</l>
<l>        clear_window (WindowHandle)</l>
<l>    endif</l>
<l>    dump_window_image (Image, WindowHandle)</l>
<c>    * Special treatment for color background images necessary</c>
<l>    count_channels (Image, NumChannels)</l>
<l>    ColorImage := NumChannels == 3</l>
<c>    * </c>
<l>    create_scene_3d (Scene3D)</l>
<l>    add_scene_3d_camera (Scene3D, CamParam, CameraIndex)</l>
<l>    add_scene_3d_instance (Scene3D, ObjectModel3D, Poses, AllInstances)</l>
<c>    * Always set 'disp_background' to true,  because it is handled explicitly</c>
<c>    * in this procedure (see above)</c>
<l>    set_scene_3d_param (Scene3D, 'disp_background', 'true')</l>
<c>    * Check if we have to set light specific parameters</c>
<l>    SetLight := regexp_test(GenParamName,'light_')</l>
<l>    if (SetLight)</l>
<c>        * set position of light source</c>
<l>        Indices := find(GenParamName,'light_position')</l>
<l>        if (Indices != -1 and Indices != [])</l>
<c>            * If multiple light positions are given, use the last one</c>
<l>            LightParam := number(split(GenParamValue[Indices[|Indices| - 1]],', '))</l>
<l>            if (|LightParam| != 4)</l>
<l>                throw ('light_position must be given as a string that contains four space separated floating point numbers')</l>
<l>            endif</l>
<l>            LightPosition := LightParam[0:2]</l>
<l>            LightKind := 'point_light'</l>
<l>            if (LightParam[3] == 0)</l>
<l>                LightKind := 'directional_light'</l>
<l>            endif</l>
<c>            * Currently, only one light source is supported</c>
<l>            remove_scene_3d_light (Scene3D, 0)</l>
<l>            add_scene_3d_light (Scene3D, LightPosition, LightKind, LightIndex)</l>
<l>            tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>            tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>        endif</l>
<c>        * set ambient part of light source</c>
<l>        Indices := find(GenParamName,'light_ambient')</l>
<l>        if (Indices != -1 and Indices != [])</l>
<c>            * If the ambient part is set multiple times, use the last setting</c>
<l>            LightParam := number(split(GenParamValue[Indices[|Indices| - 1]],', '))</l>
<l>            if (|LightParam| &lt; 3)</l>
<l>                throw ('light_ambient must be given as a string that contains three space separated floating point numbers')</l>
<l>            endif</l>
<l>            set_scene_3d_light_param (Scene3D, 0, 'ambient', LightParam[0:2])</l>
<l>            tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>            tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>        endif</l>
<c>        * Set diffuse part of light source</c>
<l>        Indices := find(GenParamName,'light_diffuse')</l>
<l>        if (Indices != -1 and Indices != [])</l>
<c>            * If the diffuse part is set multiple times, use the last setting</c>
<l>            LightParam := number(split(GenParamValue[Indices[|Indices| - 1]],', '))</l>
<l>            if (|LightParam| &lt; 3)</l>
<l>                throw ('light_diffuse must be given as a string that contains three space separated floating point numbers')</l>
<l>            endif</l>
<l>            set_scene_3d_light_param (Scene3D, 0, 'diffuse', LightParam[0:2])</l>
<l>            tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>            tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Handle persistence parameters separately because persistence will</c>
<c>    * only be activated immediately before leaving the visualization</c>
<c>    * procedure</c>
<l>    PersistenceParamName := []</l>
<l>    PersistenceParamValue := []</l>
<c>    * Set position of light source</c>
<l>    Indices := find(GenParamName,'object_index_persistence')</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        if (GenParamValue[Indices[|Indices| - 1]] == 'true')</l>
<l>            PersistenceParamName := [PersistenceParamName,'object_index_persistence']</l>
<l>            PersistenceParamValue := [PersistenceParamValue,'true']</l>
<l>        elseif (GenParamValue[Indices[|Indices| - 1]] == 'false')</l>
<l>        else</l>
<l>            throw ('Wrong value for parameter \'object_index_persistence\' (must be either \'true\' or \'false\')')</l>
<l>        endif</l>
<l>        tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>        tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>    endif</l>
<l>    Indices := find(GenParamName,'depth_persistence')</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        if (GenParamValue[Indices[|Indices| - 1]] == 'true')</l>
<l>            PersistenceParamName := [PersistenceParamName,'depth_persistence']</l>
<l>            PersistenceParamValue := [PersistenceParamValue,'true']</l>
<l>        elseif (GenParamValue[Indices[|Indices| - 1]] == 'false')</l>
<l>        else</l>
<l>            throw ('Wrong value for parameter \'depth_persistence\' (must be either \'true\' or \'false\')')</l>
<l>        endif</l>
<l>        tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>        tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Parse the generic parameters</c>
<c>    * - First, all parameters that are understood by set_scene_3d_instance_param</c>
<l>    AlphaOrig := gen_tuple_const(NumModels,1)</l>
<l>    for I := 0 to |GenParamName| - 1 by 1</l>
<l>        ParamName := GenParamName[I]</l>
<l>        ParamValue := GenParamValue[I]</l>
<c>        * Check if this parameter is understood by set_scene_3d_param</c>
<l>        if (ParamName == 'alpha')</l>
<l>            AlphaOrig := gen_tuple_const(NumModels,ParamValue)</l>
<l>        endif</l>
<l>        try</l>
<l>            set_scene_3d_param (Scene3D, ParamName, ParamValue)</l>
<l>            continue</l>
<l>        catch (Exception)</l>
<l>            if (Exception[0] == 1203 or Exception[0] == 1303)</l>
<l>                throw ('Wrong type or value for parameter ' + ParamName + ': ' + ParamValue)</l>
<l>            endif</l>
<l>        endtry</l>
<c>        * Check if it is a parameter that is valid for only one instance</c>
<c>        * and therefore can be set only with set_scene_3d_instance_param</c>
<l>        ParamNameTrunk := regexp_replace(ParamName,'_\\d+$','')</l>
<l>        if (ParamName == ParamNameTrunk)</l>
<l>            Instance := [0:NumModels - 1]</l>
<l>        else</l>
<l>            Instance := number(regexp_replace(ParamName,'^' + ParamNameTrunk + '_(\\d+)$','$1'))</l>
<l>            if (Instance &lt; 0 or Instance &gt; NumModels - 1)</l>
<l>                throw ('Parameter ' + ParamName + ' refers to a non existing 3D object model')</l>
<l>            endif</l>
<l>        endif</l>
<l>        try</l>
<l>            set_scene_3d_instance_param (Scene3D, Instance, ParamNameTrunk, ParamValue)</l>
<l>        catch (Exception)</l>
<l>            if (Exception[0] == 1204 or Exception[0] == 1304)</l>
<l>                throw ('Wrong type or value for parameter ' + ParamName + ': ' + ParamValue)</l>
<l>            elseif (Exception[0] == 1203 or Exception[0] == 1303)</l>
<l>                throw ('Wrong parameter name ' + ParamName)</l>
<l>            else</l>
<l>                throw (Exception)</l>
<l>            endif</l>
<l>        endtry</l>
<l>        if (ParamNameTrunk == 'alpha')</l>
<l>            AlphaOrig[Instance] := ParamValue</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * </c>
<c>    * Start the visualization loop</c>
<l>    pose_to_hom_mat3d (Poses[0:6], HomMat3D)</l>
<l>    affine_trans_point_3d (HomMat3D, Center[0], Center[1], Center[2], Qx, Qy, Qz)</l>
<l>    TBCenter := [Qx,Qy,Qz]</l>
<l>    TBSize := (0.5 + 0.5 * sum(SelectedObject) / NumModels) * TrackballRadiusPixel</l>
<l>    ButtonHold := false</l>
<l>    while (1)</l>
<l>        VisualizeTB := max(SelectedObject) != 0</l>
<l>        MaxIndex := min([|ObjectModel3D|,MaxNumModels]) - 1</l>
<c>        * Set trackball fixed in the center of the window</c>
<l>        TrackballCenterRow := Height / 2</l>
<l>        TrackballCenterCol := Width / 2</l>
<l>        if (WindowCenteredRotation == 1)</l>
<l>            try</l>
<l>                get_trackball_center_fixed (SelectedObject[0:MaxIndex], TrackballCenterRow, TrackballCenterCol, TrackballRadiusPixel, Scene3D, ObjectModel3D[0:MaxIndex], Poses[0:(MaxIndex + 1) * 7 - 1], WindowHandleBuffer, CamParam, GenParamName, GenParamValue, TBCenter, TBSize)</l>
<l>            catch (Exception)</l>
<l>                disp_message (WindowHandle, 'Surface inspection mode is not available.', 'image', 5, 20, 'red', 'true')</l>
<l>                WindowCenteredRotation := 2</l>
<l>                get_trackball_center (SelectedObject[0:MaxIndex], TrackballRadiusPixel, ObjectModel3D[0:MaxIndex], Poses[0:(MaxIndex + 1) * 7 - 1], TBCenter, TBSize)</l>
<l>                wait_seconds (1)</l>
<l>            endtry</l>
<l>        else</l>
<l>            get_trackball_center (SelectedObject[0:MaxIndex], TrackballRadiusPixel, ObjectModel3D[0:MaxIndex], Poses[0:(MaxIndex + 1) * 7 - 1], TBCenter, TBSize)</l>
<l>        endif</l>
<l>        dump_image_output (Image, WindowHandleBuffer, Scene3D, AlphaOrig, ObjectModel3D, GenParamName, GenParamValue, CamParam, Poses, ColorImage, Title, Information, Label, VisualizeTB, 'true', TrackballCenterRow, TrackballCenterCol, TBSize, SelectedObject, WindowCenteredRotation, TBCenter)</l>
<l>        dump_window_image (ImageDump, WindowHandleBuffer)</l>
<l>        dev_set_window (WindowHandle)</l>
<l>        dev_display (ImageDump)</l>
<c>        * </c>
<c>        * Check for mouse events</c>
<l>        GraphEvent := false</l>
<l>        Exit := false</l>
<l>        while (1)</l>
<c>            * </c>
<c>            * Check graphic event</c>
<l>            try</l>
<l>                get_mposition_sub_pix (WindowHandle, GraphButtonRow, GraphButtonColumn, GraphButton)</l>
<l>                if (GraphButton != 0)</l>
<l>                    if (GraphButtonRow &gt; Height - TextHeight - 25 and GraphButtonRow &lt; Height and GraphButtonColumn &gt; Width - TextWidth - 15 and GraphButtonColumn &lt; Width)</l>
<c>                        * Wait until the continue button has been released</c>
<l>                        if (WaitForButtonRelease == 'true')</l>
<l>                            while (1)</l>
<l>                                get_mposition_sub_pix (WindowHandle, GraphButtonRow, GraphButtonColumn, GraphButton)</l>
<l>                                if (GraphButton == 0 or GraphButton == [])</l>
<l>                                    if (GraphButtonRow &gt; Height - TextHeight - 25 and GraphButtonRow &lt; Height and GraphButtonColumn &gt; Width - TextWidth - 15 and GraphButtonColumn &lt; Width)</l>
<l>                                        ButtonReleased := true</l>
<l>                                    else</l>
<l>                                        ButtonReleased := false</l>
<l>                                    endif</l>
<c>                                    * </c>
<l>                                    break</l>
<l>                                endif</l>
<c>                                * Keep waiting until mouse button is released or moved out of the window</c>
<l>                            endwhile</l>
<l>                        else</l>
<l>                            ButtonReleased := true</l>
<l>                        endif</l>
<c>                        * Exit the visualization loop</c>
<l>                        if (ButtonReleased)</l>
<l>                            Exit := true</l>
<l>                            break</l>
<l>                        endif</l>
<l>                    endif</l>
<l>                    GraphEvent := true</l>
<l>                    break</l>
<l>                else</l>
<l>                    ButtonHold := false</l>
<l>                endif</l>
<l>            catch (Exception)</l>
<c>                * Keep waiting</c>
<l>            endtry</l>
<l>        endwhile</l>
<l>        if (GraphEvent)</l>
<l>            analyze_graph_event (Image, MouseMapping, GraphButton, GraphButtonRow, GraphButtonColumn, WindowHandle, WindowHandleBuffer, VirtualTrackball, TrackballSize, SelectedObject, Scene3D, AlphaOrig, ObjectModel3D, CamParam, Label, Title, Information, GenParamName, GenParamValue, Poses, ButtonHold, TBCenter, TBSize, WindowCenteredRotation, MaxNumModels, Poses, SelectedObject, ButtonHold, WindowCenteredRotation)</l>
<l>        endif</l>
<l>        if (Exit)</l>
<l>            break</l>
<l>        endif</l>
<l>    endwhile</l>
<c>    * </c>
<c>    * Display final state with persistence, if requested</c>
<c>    * Note that disp_object_model_3d must be used instead of the 3D scene</c>
<l>    if (|PersistenceParamName| &gt; 0)</l>
<l>        try</l>
<l>            disp_object_model_3d (WindowHandle, ObjectModel3D, CamParam, Poses, ['disp_background','alpha',PersistenceParamName], ['true',0.0,PersistenceParamValue])</l>
<l>        catch (Exception)</l>
<l>            stop ()</l>
<l>        endtry</l>
<l>    endif</l>
<c>    * </c>
<c>    * Compute the output pose</c>
<l>    if (gIsSinglePose)</l>
<l>        PoseOut := Poses[0:6]</l>
<l>    else</l>
<l>        PoseOut := Poses</l>
<l>    endif</l>
<c>    * </c>
<c>    * Clean up</c>
<l>    set_system ('clip_region', ClipRegion)</l>
<l>    dev_set_preferences ('graphics_window_context_menu', 'true')</l>
<l>    dev_set_preferences ('suppress_handled_exceptions_dlg', SuppressExceptDlg)</l>
<l>    dev_set_preferences ('graphics_window_mouse_wheel', WindowMouseWheel)</l>
<l>    dump_image_output (Image, WindowHandleBuffer, Scene3D, AlphaOrig, ObjectModel3D, GenParamName, GenParamValue, CamParam, Poses, ColorImage, Title, [], Label, 0, 'false', TrackballCenterRow, TrackballCenterCol, TBSize, SelectedObject, WindowCenteredRotation, TBCenter)</l>
<l>    dump_window_image (ImageDump, WindowHandleBuffer)</l>
<l>    dev_set_window (WindowHandle)</l>
<l>    dev_display (ImageDump)</l>
<l>    close_window (WindowHandleBuffer)</l>
<l>    set_part (WindowHandle, WPRow1, WPColumn1, WPRow2, WPColumn2)</l>
<l>    clear_scene_3d (Scene3D)</l>
<l>    Scene3D := []</l>
<l>catch (Exception)</l>
<l>    try</l>
<l>        if (0 &lt; |Scene3DTest|)</l>
<l>            clear_scene_3d (Scene3DTest)</l>
<l>            Scene3DTest := []</l>
<l>        endif</l>
<l>        if (0 &lt; |Scene3D|)</l>
<l>            clear_scene_3d (Scene3D)</l>
<l>            Scene3D := []</l>
<l>        endif</l>
<l>        if (0 &lt; |WindowHandleBuffer|)</l>
<l>            close_window (WindowHandleBuffer)</l>
<l>            WindowHandleBuffer := []</l>
<l>        endif</l>
<l>    catch (e)</l>
<c>        * suppress all further exceptions to return the original exception</c>
<l>    endtry</l>
<c></c>
<l>    throw (Exception)</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="visualize_object_model_3d">
<abstract lang="en_US">The procedure visualize_object_model_3d displays the 3D object models of ObjectModel3D in the window with the handle WindowHandle and allows to interactively modify the object poses with the mouse. The current content of the window will be kept as background.

The pose can be modified by moving the mouse while pressing a mouse button. The default settings are:

- Rotate: Left mouse button
- Zoom: Shift + Left mouse button (or Center mouse button)
- Pan: Ctrl + Left mouse button

Furthermore, it is possible to select and deselect objects, to decrease the mouse sensitivity, and to toggle the inspection mode (see the description of the generic parameter 'inspection_mode' below):

- (De-)select object(s): Right mouse button
- Low mouse sensitivity: Alt + Mouse button
- Toggle inspection mode: Ctrl + Alt + Left mouse button

Note that the selection of individual 3D object models is only available, if the number of models is not greater than 1000 (or the value passed with the generic parameter 'max_num_selectable_models', see below).

Set CamParam and the individual poses (in PoseIn) of the 3D object models to setup the displayed scene. 
If an empty tuple is given for CamParam, visualize_object_model_3d uses default camera parameters that correspond to the window size.
PoseIn can contain either multiple poses (one for each 3D object model) or one pose for all 3D object models.
If an empty tuple is given for PoseIn, visualize_object_model_3d estimates a pose, such that all 3D object models are visible.

The parameter Title can be used to specify text that will be displayed in a box at the top of the window.

The parameter Label can be used to specify a list of labels, which are displayed aligned with the corresponding 3D object model. It must either contain one entry per 3D object model or it must be empty.

The parameter Information can be used to specify text that is displayed without a box at the bottom left of the window.

The output parameter PoseOut contains the possibly modified poses used for the visualization of the 3D object models. These poses can be used directly in disp_object_model_3d and render_object_model_3d or in visualize_object_model_3d to start the visualization with exactly the poses that have been chosen interactively.

The visualization can be configured with a set of parameters, which are given in GenParamName and GenParamValue. The detailed description  of these parameters can be found in the reference documentation of disp_object_model_3d.

The following values influence the whole scene: 

'disp_background':
Flag, if the current window content should be used as background.
Values: 'true' or 'false'
Default: 'false' 

'opengl':
Decides if  OpenGL is used to display the 3D object models. Otherwise the CPU based fallback solution is used.
Values: 'true' or 'false'
Default: 'true' 

'light_position':
Position of the light source. Must be given as a string containing four space separated floating point numbers. If the fourth number is 0.0, a directional light source is used (the first three components represent the direction), otherwise a point light source is used (with the first three components representing the position). 
Default: '-100.0 -100.0 0.0 1.0'

'light_ambient':
Ambient part of the light source. Must be given as a string containing three space separated floating point numbers.
Default value: '0.2 0.2 0.2'

'light_diffuse':
Diffuse part of the light source. Must be given as a string containing three space separated floating point numbers.
Default value: '0.8 0.8 0.8' 

'colored':
Display object models in different colors. The value of this parameter defines the number of colors that are used.
Values: 3, 6, or 12
Default: all objects are white 

'object_index_persistence':
Must be set to 'true' to enable the object index query in get_disp_object_model_3d_info.
Values: 'true' or 'false'
Default: 'false' 

'depth_persistence':
Must be set to 'true' to enable the depth query in get_disp_object_model_3d_info.
Values: 'true' or 'false'
Default: 'false' 

The following parameters can be set for all objects in the scene or for a specific object by appending the index of the object to the parameter name (e.g., 'color_0' to set the color of the first object).

'attribute'
Explicitly select in which way a 3D object model is visualized.
Values: 'auto', 'faces', 'primitive', 'points', 'lines'
Default Value: 'auto'

'color':
Color of the 3D object model. The available colors can be queried with the operator query_color. In addition, the color may be specified as an RGB triplet in the form '#rrggbb', where 'rr', 'gg', and 'bb' are hexadecimal numbers between '00' and 'ff', respectively.
Values: 'red', 'green', ...
Default value: 'white'

'alpha':
Transparency of the 3D object models. Displaying 3D object models with transparency set to less than 1.0 may significantly increase the runtime ofdisplay_scene_3d and render_scene_3d.
Values: floating point value between 0.0 (fully transparent) and 1.0 (fully opaque).
Default value: 1.0

'disp_pose':
Flag, if the pose of the 3D object models should be visualized.
Values: 'true' or 'false'
Default value: 'false'

'disp_lines':
Flag, if the contours of the 3D object models' polygons should be displayed.
Values: 'true' or 'false'
Default value: 'false'

'disp_normals':
Flag, if the surface normals of the 3D object models should be visualized.
Values: 'true' or 'false'
Default value: 'false'

'line_color':
Color of the lines if 'disp_lines' is set to 'true'. The available colors can be queried with the operator query_color. In addition, the color may be specified as an RGB triplet in the form '#rrggbb', where 'rr', 'gg', and 'bb' are hexadecimal numbers.
Values: 'red', 'green', ...
Default value: The value of 'color'

'line_width':
Sets the width of lines in pixel.
Default value: 1.0

'normal_color':
Color of the visualized normals if 'disp_normals' is set to 'true'. The available colors can be queried with the operator query_color. In addition, the color may be specified as an RGB triplet in the form '#rrggbb', where 'rr', 'gg', and 'bb' are hexadecimal numbers.
Values: 'red', 'green', ...
Default value: The value of 'color'

'point_size':
Sets the diameter of the points in pixel.
Default value: 3.5

'lut':
Sets the LUT that transforms the values of the attribute set with 'color_attrib' into a color.
See set_lut for available LUTs. If 'lut' is set to anything but 'default', 'color' is ignored.
Default value: 'default'

'color_attrib':
Name of a point attribute that is used for false color visualization.
If an attribute is set, the color of the displayed 3D points is determined by the point's attribute value and the currently set LUT (see 'lut'). This way, it is possible to visualize attributes in false colors.
Example: If 'color_attrib' is set to 'coord_z', and 'lut' is set to 'color1', the z-coordinates will be color coded from red to blue.
If 'lut' is set to 'default', the attribute values are used to scale the color that was set by the parameter 'color'.
If 'lut' is set to a different value, the attribute values of all points are internally scaled to the interval [0,255] and used as input value for the LUT function.
The mapping is also controlled by the parameters 'color_attrib_start' and 'color_attrib_end' (see below).
If faces are displayed, their color is interpolated between the color of the corner points.
Values: 'none', '&amp;distance', 'coord_x', 'coord_y', 'coord_z', user defined point attributes, or any other point attribute available.
Default: 'none'

'color_attrib_start','color_attrib_end':
The range of interest of the values of the attribute set with 'color_attrib'.
The attribute values between 'color_attrib_start' and 'color_attrib_end' are scaled to the start and end of the selected LUT. Attribute values outside the selected range are clipped. This allows to use a fixed color mapping which will not be distorted by outliers.
If set to 'auto', the minimum attribute value is mapped to the start of the LUT, the maximum is mapped to the end of the LUT, except if 'color_attrib' is 'normal_x','normal_y', or 'normal_z'. In this case, start and end are automatically set to -1 and 1.
It is possible to enter start value that is higher than the end value. This will in effect flip the used LUT.
Values: 0, 0.1, 1, 100, 255, ...
Default value: 'auto'

'red_channel_attrib', 'green_channel_attrib', 'blue_channel_attrib':
Name of a point attribute that is used for the red, green, or blue color channel.
This is most useful when used with a group of three connected attributes, like RGB colors or normal vectors. This way it is possible to display points in colored texture, e.g., display the object model with overlayed RGB-sensor data, or display point normals in false colors.
To display only a single attribute in false colors, please use 'color_attrib' (see above).
By default, the attribute values are assumed to lie between 0 and 255. If the attributes have a different range, you additionally have to set the parameters'rgb_channel_attrib_start' and 'rgb_channel_attrib_end' (see below).
If only 1 or 2 channels are set, the remaining channels use the RGB value of the color set with 'color'.
If faces are displayed, their color is interpolated between the color of the corner points.
Values: 'none', '&amp;red','&amp;green','&amp;blue', 'normal_x', 'normal_y', 'normal_z', user defined point attributes, or any other point attribute available.
Default: 'none'

'rgb_channel_attrib_start', 'rgb_channel_attrib_end':
The range of interest of the values of attributes set with 'red_channel_attrib', 'green_channel_attrib', and 'blue_channel_attrib'.
These parameters define the value range that is scaled to the full RGB channels. This is useful, if the input attribute values are not in the interval [0,255].
If set to 'auto', the minimum attribute value is mapped to 0, the maximum is mapped to 255, except if the attribute is 'normal_x', 'normal_y', or 'normal_z'. In this case, start and end are automatically set to -1 and 1.
It is possible to enter start value that is higher than the end value. This will in effect invert the displayed RGB colors.
The range can be set for the channels individually by replacing 'rgb' in the parameter name with the channel name, e.g., 'green_channel_attrib_start'.
Values: 'auto', 0, 0.1, 1, 100, 255, ...
Default values: 0, 255

The following value defines the maximum number of models, for which the selection of individual models is available:

'max_num_selectable_models':
Number of 3D Object models that can be selected and handled individually. If there are more models passed then this number, some calculations are performed differently and for reasons of efficiency, the individual selection and handling of models is not supported anymore.
Values: 1, 2, ...
Default: 1000

The following value influences the handling how the pose can be modified interactively: 

'inspection_mode':
Flag that controls the initial state of the inspection mode.
If 'inspection_mode' is set to 'standard', the rotation center is fixed in the center of the displayed object. In this mode, the rotation center is indicated by a vertical cross (+). This mode is  particularly well suited for getting an impression of the whole object.
If 'inspection_mode' is set to 'surface', the rotation center is fixed in the center of the window and it lies on the surface of the displayed object. In this mode, the rotation center is indicated by a diagonal cross (x). This mode is particularly well suited for a detailed inspection of the object's surface. It is less suitable for the inspection of point clouds, because they do not provide surface information.
Note that the trackball itself is kept in the center of the image, regardless of the selected inspection mode. Note also that the inspection mode can be toggled interactively during the visualization with Ctrl + Alt + Left mouse button (see above).
Values: 'standard' or 'surface'
Default: 'standard''
  </abstract>
<alternatives>
<item>disp_object_model_3d</item>
</alternatives>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<example lang="en_US">read_object_model_3d ('pipe_joint', 'm', [], [], ObjectModel3D1, Status)
read_object_model_3d ('clamp_sloped', 'mm', [], [], ObjectModel3D2, Status)
gen_cam_par_area_scan_division (0.016, 0, 5e-6, 5e-6, 320, 240, 640, 480, CamParam)
get_cam_par_data (CamParam, 'image_width', Width)
get_cam_par_data (CamParam, 'image_height', Height)
dev_open_window (0, 0, Width, Height, 'black', WindowHandle)
create_pose (-0.02, 0.01, .6, 110, 5, 320, 'Rp+T', 'gba', 'point', Pose1)
create_pose (0.01, 0.03, .6, 130, 315, 340, 'Rp+T', 'gba', 'point', Pose2)
visualize_object_model_3d (WindowHandle, [ObjectModel3D1, ObjectModel3D2], \ 
                           CamParam, [Pose1, Pose2], \
                           ['alpha', 'color_0', 'color_1', 'disp_pose'], \
                           [0.5,     'orange',  'yellow',  'true'], \
                           ['3D visualization demo'], ['pipe joint', 'clamp'], \
                           ['Use mouse to change view'], PoseOut)</example>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>read_object_model_3d</item>
<item>gen_object_model_3d_from_points</item>
</predecessor>
<see_also>
<item>disp_object_model_3d</item>
</see_also>
<short lang="en_US">Interactively display 3D object models</short>
<successor>
<item>clear_object_model_3d</item>
</successor>
<parameters>
<parameter id="CamParam">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Camera parameters of the scene.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="GenParamName">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Names of the generic parameters. All generic parameters of disp_object_model_3d can be passed here as well.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'alpha'</item>
<item>'attribute'</item>
<item>'color'</item>
<item>'colored'</item>
<item>'disp_background'</item>
<item>'disp_lines'</item>
<item>'disp_normals'</item>
<item>'disp_pose'</item>
<item>'inspection_mode'</item>
<item>'intensity'</item>
<item>'intensity_red'</item>
<item>'intensity_green'</item>
<item>'intensity_blue'</item>
<item>'light_position'</item>
<item>'light_ambient'</item>
<item>'light_diffuse'</item>
<item>'line_color'</item>
<item>'line_width'</item>
<item>'lut'</item>
<item>'max_num_selectable_models'</item>
<item>'normal_color'</item>
<item>'point_size'</item>
</values>
</parameter>
<parameter id="GenParamValue">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Values of the generic parameters. All generic parameters of disp_object_model_3d can be passed here as well.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>'true'</item>
<item>'false'</item>
<item>'coord_x'</item>
<item>'coord_y'</item>
<item>'coord_z'</item>
<item>'red'</item>
<item>'green'</item>
<item>'blue'</item>
<item>'auto'</item>
<item>'faces'</item>
<item>'primitive'</item>
<item>'points'</item>
<item>'lines'</item>
<item>'normal_x'</item>
<item>'normal_y,'normal_z'</item>
<item>'standard'</item>
<item>'surface'</item>
</values>
</parameter>
<parameter id="Information">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Text that is to be displayed in the lower left corner of the output graphics window.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Label">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Text that is to be displayed at the position of each displayed object model.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ObjectModel3D">
<default_type>integer</default_type>
<description lang="en_US">Handles of the 3D object models.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PoseIn">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">3D poses of the objects.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="PoseOut">
<default_type>real</default_type>
<description lang="en_US">Poses of all object models that were possibly interactively changed by the user.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Title">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Text that is to be displayed in the upper left corner of the output graphics window.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Window identifier.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
</hdevelop>
